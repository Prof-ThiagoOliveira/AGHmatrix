#########################################################################
# 									#
# Package: AGH-matrix 							#
# 									#
# File: data.treat.R							#
# Contains: data.treat 							#
# 									#
# Written by Rodrigo Rampazo Amadeu 					#
# 									#
# First version: Feb-2014 						#
# Last update: 24-Apr-2015 						#
# License: GNU General Public License version 2 (June, 1991) or later 	#
# 									#
#########################################################################

#' Organizes pedigree data in a chronological way
#'
#' This function organizes pedigree data in a chronological way and return 3 lists: i) parental 1 values (numeric); ii) parental 2 values (numeric); iii) real names of the individuals. Also save a .txt file with new pedigree file.
#' @param file name of the pedigree data file with quotes (e.g. "pedigree.txt"). Deafult=NULL.
#' @param unk the code of the data missing. Default=0.
#' @param n.max max number of iteractions to get the chronological order. Default = 50
#'
#' @return list with parental 1, parental 2, and real names of the individuals (key) also saves a txt file with the new chronological pedigree.
#'
#' @examples data.treat()
#'
#' @author Rodrigo R Amadeu, \email{rramadeu@@gmail.com}
#'
#' @export

data.treat <- function(data=NULL,
                       n.max=50,
                       unk=0,
                       save=FALSE
                       ){
    indicator <- k <-  0
    if(is.null(data))
        stop(deparse("Select a data name"))

    
    for( i in 1:n.max){

                                        #Data Treatment
      if( i == 1){
          data <- as.matrix(data)
          k <- rep(NA,2) #only for don't stop the loop on the first time
      }
      if( i > 1 )
          data <- new.data
      pedigree <- asciitonumber(data,unk=unk)
      ind.data <- pedigree$ind.data
      sire <- pedigree$sire
      dire <- pedigree$dire
      ind <- c(1:length(sire))

      right.pos <- rep(NA, length=length(sire))

  #Verify alternatively sire and dire each iteraction+1
      parent <- sire
      parent.ind <- "sire"

      if( indicator%%2 == 1 ){
      parent <- dire
      parent.ind <- "dire"
  }


      for ( j in 1:length(parent)){
      if( is.na(match(parent[j], ind[1:j])) && parent[j] != 0){
          right.pos[j] <- which(ind == parent[j])
      }
  }

      error <- c()
      for( j in 1:length(parent))
          if( parent[j] > j)
              error <- c(error,j)

                                        #Print the step point
      if( save ){
      cat( paste("iteraction #",i,parent.ind,"\n",sep=""))
      cat( paste(error,"\n"))
  }


                                        #Right positions of the new data
      if( length(error) > 0 ){
          after <- which( !is.na(right.pos))
          before <- right.pos[after]
          for( j in 1:length(before)){
              if( j == 1 || before[j] != before[j-1] ){
                  ind[after[j]] <- before[j]
                  ind[before[j]] <- after[j]
              }
          }
      }
      new.data <- data[ind,]


                                        # Verify changes in the loop
      lastk <- k #indicator that there is no more changes in the last parent
      k <- length(error) #indicator that no changes


      if (  k == 0 )
          indicator = indicator+1

      if ( i != 1 && k == 0 && lastk == 0 ){
          cat("Your data was chronologically organized with success. \n")
          if(save){
            cat(paste("orgnew.txt",sep=""))
            write.table(new.data,  file=paste("orgped.txt",sep=""), quote=FALSE, row.names=FALSE, col.names=FALSE)
        }
          return(pedigree)
      }

      if ( i == n.max ){
          cat("Your data was not chronologically organized with sucess. Check your data with missing.data function and/or verify the individuals in the 2 last iteractions above descripted (the number is the row in the file: \n")
          cat(paste("orgped.txt",sep=""))
          write.table(new.data, file=paste("orgped.txt",sep=""), quote=FALSE, row.names=FALSE, col.names=FALSE)
          return(pedigree)
      }
  }
}
